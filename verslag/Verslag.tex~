\documentclass[a4paper,10pt]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{fancyvrb }
\usepackage{listings}
\usepackage[a4paper,bindingoffset=0.2in,%
            left=1in,right=1in,top=1in,bottom=1in,%
            footskip=.25in]{geometry}

\lstdefinestyle{numbered}{
 numbers=left,               % Ort der Zeilennummern
 stepnumber=1,               % Abstand zwischen den Zeilennummern       
 numberfirstline=false
}

\title{Alphi}
\author{Tobiah Lissens}
\date{14-01-2017}

\begin{document}

\maketitle
\newpage
\tableofcontents
\newpage

\section{Inleiding}
In dit project wordt de eenvoudige programmeertaal Alphi opgesteld.
Hierbij is het de bedoeling verschillende basiselementen van een imperatieve programmeertaal te implementeren:
zoals toekenning, variabelen en volgorde van bewerkingen.
De taal die hieronder wordt uitgewerkt heet Alphi, wat staat voor alphanumerical.
Deze taal maakt enkel gebruik van alphanumerische karakters met de uitzondering dat whitespace ook is toegestaan.
Eerst zal de syntax worden vastgelegd.
Vervolgens wordt de semantiek vastgelegd en worden voorbeeldprogramma's gegeven.
Hierna worden de implementatie-aspecten besproken.
Als laatste worden nog enkele mogelijke verbeteringen of aanpassingen voorgesteld.

\newpage
\section{Syntax}
    BNF notatie van de Alphi taal.\\
    note: Soms word de [0-9] notatie gebruikt om ranges aan te duiden.
    \lstinputlisting{bnf.txt}

\section{Semantiek}
qsdfqsdf
\section{Programma's}
Korte beschrijvingen van het programma
  \subsection{demo\_police.alp}
 (zie Appendix Broncode)\\
   Start teller.\\
   Indien teller even zet Led1 op rood en led 2 op blauw.\\
   Indien teller oneven zet led2 op rood en led1 op blauw.\\
   Verhoog Teller met 1\\
   Begin bij stap 2.
  \subsection{demo\_police.alp}
  (zie Appendix Broncode)\\
  Lees beide lichtsensoren uit.\\
  Indien beide sensoren Zwart zien rij de robot rechtdoor.\\
  Indien links wit ziet en rechts zwart draai alleen de linker motor.\\
  Indien rechts wit ziet en links zwart draai alleen de rechter motor.\\
  Indien Beide wit zien rij achteruit.\\
  Begin terug bij stap 1.
  \subsection{demo\_ultra.alp}
 (zie Appendix Broncode)\\
  Lees Ultrasonesensor uit.\\
  Indien afstand Groter dan 40 rij rechtdoor.\\
  Indien afstand Kleiner dan 40 draai de linkermotor vooruit en de rechtermotor achteruit.\\
  Begin terug bij stap 1.

\section{Implementatie}

  Hier worden kort de interessante functies aangeraakt.
  \subsection{Parsen}
    \subsubsection{Base.hs}
    Hier werd de Parser monad geimplementeerd. Het grootste deel van de code komt uit de slides over monads.
    Wel belangrijk te noteren dat de option uit alternative en de mplus uit de monadplus anders geïmplementeerd zijn.
    Hier volgt een omschrijving van hun implementatie.

      \begin{verbatim}
      Monadplus:
      Zie Parser.Base line ?
      mzero = gefaalde parser.
      mplus p1 p2 = probeer parser 1 en ook parser2.
      \end{verbatim}

      \begin{verbatim}
      Alternative:
      Zie Parser.Base line ?
      empty = gefaalde parser.
      option p1 p2 = indien parser 1 faalt probeer parser2.
      \end{verbatim}
  \subsubsection{Util.hs}
    Hier werden alle Parser functies geimplementeerd die nergens anders een plaats hadden.
    Twee interessante functies zijn matchStr en chainl1.
      \begin{verbatim}
      matchStr:
      Zie Parser.Util line ?
      matchStr s = match een bepaalde string en minstens een whitespace karakter 
                   of commentaar.
      \end{verbatim}
      \begin{verbatim}
      chainl1:
      Zie Parser.Uitl line ?
      chainl1 :: Parser a -> Parser (a -> a -> a) -> Parser a
      chainl1 p op = neemt 2 parsers binnen 1 gewone parser en 1 operator parser 
                     en zal de operator parser met laagste prioriteit toepassen.
      \end{verbatim}


  \subsubsection{NumericalParser.hs/BooleanParser.h/StatementParser.hs}
  Hier staan alle taal parsers. Deze brengen echter weinig nieuwigheden en
  combineren gewoon parsers uit base of util om aan hun speciefieke resultaat te komen.



\subsection{Evalueren}
  Bij het evalueren wordt er gebruik gemaakt van een StateT monad transformer waarin een IO monad zit.
  Hierdoor kunnen we bij het evalueren statefull werken. Deze State zal de variabelen mappen naar waarden,
  Zodat we later de waardes van variabelen kunnen opvragen.
  De State zal ook return waardes van expressies teruggeven.
  
  \subsubsection{NumericEval.hs / BoolEval.hs}

    Het idee hierbij is te pattern matchen op de datastructuur. Op deze manier kunnen we elk geval apart behandelen.
    Voor functies die veel voorkomen wordt een abstractere versie aangemaakt in Evaluator.Util.hs.
    Een mooi voorbeeld hiervan is de functie EvalBOp zie Evaluator.Util.hs line ?.
    EvalBOp is een functie die 6 argumenten neemt.
    \begin{enumerate}
      \item Functie die 2 a's binnen neemt en een a teruggeeft
      \item Expressie1 een expressie
      \item Expressie2 een expressie
      \item Evaluator1
      \item Unwrapper (m a -> a) functie die een return value unwrapped
      \item Constructor Wrapper constructor
    \end{enumerate}
    Deze functie zal de 2 expressies uitrekenen.
    Vervolgens zal deze de return waarden daarvan uitpakken en tenslotte
    de functie erop toepassen en als laatste deze terug wrappen en in een MyState steken.

  \subsubsection{StatementEval.hs}
  De StatementEval werkt op dezelfde manier als NumericEval en BoolEval.
  Maar bij het evalueren moet in onze statemonad aan IO gedaan worden.
  Dit omdat we met onze robot/standaardout willen kunnen communiceren.
  De functies evalInput'(line ?), evalPrint (line ? ) en evalRobotFunction (line ?) maken om dit te kunnen doen gebruik van liftIO.

\subsection{RobotLib}
  \subsection{Robot.Base.hs}
  Hier werd verder gewerkt op de gegeven library zodat er intuïtiever gewerkt kan worden met de MBot
  En zodat er een mooie scheiding kan blijven bestaan tussen de robotaansturing en de taal Alphi.
  Een Interessante functie is de move functie. Hierbij wordt een device, snelheid en motor meegegeven
  zodat de motor makkelijker kan aangestuurd worden.
  De Implementatie kan gevonden worden onder Robot.Base.hs line ? .

\section{Mogelijke Verbeteringen}
\subsection{Taalaspecten} 
  Het gebruik van enkel alphanumerical karakters is niet aangeraden.
  Het is zowel voor de leesbaarheid als voor de moeilijkheid van het parsen beter om wel gebruik te maken van speciale karakters.
  Verder zou het leuk zijn moest de taal werkelijk statisch zijn. In de plaats van voor elke identifier een ID te zetten zoals       (Numerical) of B(Boolean).
  Dit kan gebeuren door tijdens het parsen ook een state van een environment bij te houden waarin elke variable gemapped zou worden op het type.
  Er zijn nog enkele kleine aspecten die de programmeertaal niet helemaal statisch maken zoals numerical expressions die kunnen staan als boolean in If/While Statement.
  Ook zou het leuk zijn moesten integers niet achterliggend worden geconverteerd naar doubles zoals nu het geval is.
  Als laatste Verbetering zouden multiple parameters voor bijvoorbeeld het aansturen van de leds van de robot ook handig zijn.

\subsection{Programmeeraspecten} 
In de programmeertaal zit in de implementatie van de volgorde van bewerkingen werkelijk ook volgorde van bewerkingen.
Wat ik hiermee bedoel is dat het omwisselen van 2 parsers hier er voor kan zorgen dat heel de parser niet meer werkt.
Dit komt omdat er gebruik wordt gemaakt van de chain bewerking en mplus bewerking om de parsers te combineren. Het omwisselen van 2  parsers kan hierbij echter werkelijk heel de parser breken helpen. Hierdoor zou het misschien beter zijn de manier waarop de volgorde van bewerkingen gedaan wordt te herzien en robuuster te schrijven.
\section{Conclusie}

\subsection{Algemeen}
Een alphanumerical taal maken leek in het begin leuk. Dit bracht echter enkele nadelen met zich mee.
Het grote nadeel hierbij is dat je geen speciale karakters hebt die kunnen instaan voor bijvoorbeeld het einde van een statement, haakjes etc.
Verder wordt de taal ook enorm rap onduidelijk en onleesbaar doordat er weinig tot geen onderscheid gemaakt kan worden tussen keywords en Expressies of variabelen.

\subsection{Syntax definitie}
Hierbij zijn er soms onlogische samenstellingen mogelijk zoals Numerical Expression in de IfConditie of WhileStatement
Hierdoor moet dit opgevangen worden tijdens het evalueren. Dit is ongewild.

\subsection{Implementatie}
De parseLibrary is vrij onduidelijk geschreven. Er onbreekt een mooie volgbare hierachie die bijvoorbeeld wel aanwezig is bij het evalueren.
Dit komt voornamelijk doordat er geen eenduidige manier is om dingen te parsen en er op ieder moment rekening met whitespace en commentaar gehouden moet worden.


\section{Appendix Broncode}
  \newgeometry{left=1in}
  \subsection{AlphiExamples}
    \subsubsection{demo\_police.alp}
      \lstinputlisting[style=numbered]{../AlphiExamples/demo_police.alp}
    \subsubsection{demo\_line.alp}
      \lstinputlisting[style=numbered]{../AlphiExamples/demo_line.alp}
    \subsubsection{demo\_ultra.alp}
      \lstinputlisting[style=numbered]{../AlphiExamples/demo_ultra.alp}
  \subsection{SRC}
    \subsubsection{Main.hs}
      \lstinputlisting[language=Haskell, style=numbered]{../Main.hs}
    \subsubsection{Parser.Base.hs}
      \lstinputlisting[language=Haskell, style=numbered]{../Parser/Base.hs}
    \subsubsection{Parser.NumericParser.hs}
      \lstinputlisting[language=Haskell, style=numbered]{../Parser/NumericParser.hs}
    \subsubsection{Parser.BoolParser.hs}
      \lstinputlisting[language=Haskell, style=numbered]{../Parser/BoolParser.hs}
    \subsubsection{Parser.StatementParser.hs}
      \lstinputlisting[language=Haskell, style=numbered]{../Parser/StatementParser.hs}
    \subsubsection{Parser.Util.hs}
      \lstinputlisting[language=Haskell, style=numbered]{../Parser/Util.hs}
    \subsubsection{Evaluator.NumericEval.hs}
      \lstinputlisting[language=Haskell, style=numbered]{../Evaluator/NumericEval.hs}
    \subsubsection{Evaluator.BoolEval.hs}
      \lstinputlisting[language=Haskell, style=numbered]{../Evaluator/BoolEval.hs}
    \subsubsection{Evaluator.StatementEval.hs}
      \lstinputlisting[language=Haskell, style=numbered]{../Evaluator/StatementEval.hs}
    \subsubsection{Evaluator.Util.hs}
      \lstinputlisting[language=Haskell, style=numbered]{../Evaluator/Util.hs}
    \subsubsection{Data.Base.hs}
      \lstinputlisting[language=Haskell, style=numbered]{../Data/Base.hs}
    \subsubsection{Robot.Base.hs}
      \lstinputlisting[language=Haskell, style=numbered]{../Robot/Base.hs}
  \restoregeometry
\end{document}
